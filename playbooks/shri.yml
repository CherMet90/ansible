---
- name: Setup dynamic group based on complex group logic with user inputs
  hosts: all
  gather_facts: no
  serial: 1
  vars_prompt:
    - name: must_have_groups
      prompt: "Enter the must-have groups, separated by commas (e.g., ust,cisco)"
      private: no
    - name: optional_groups
      prompt: "Enter optional groups, at least one must be present, separated by commas (e.g., poe_switch,access_switch)"
      private: no

  tasks:
    - set_fact:
        must_have_groups_list: "{{ must_have_groups.split(',') }}"
        optional_groups_list: "{{ optional_groups.split(',') }}"
    
    - name: Show list of group_names for host
      ansible.builtin.debug:
        msg: "{{ inventory_hostname }} belongs to groups: {{ group_names }}"
    
    - name: Initialize an empty flag for optional group presence
      set_fact:
        optional_group_present: false
      run_once: true
    
    - name: Check and flag if any optional group is present
      set_fact:
        optional_group_present: "{{ optional_groups_list | intersect(group_names) | length > 0 }}"
      run_once: true
      
    - name: Validate all must-have groups are present
      set_fact:
        all_must_have_groups_present: "{{ must_have_groups_list | difference(group_names) | length == 0 }}"
      run_once: true
    
    - ansible.builtin.debug:
        msg: "Must-have groups present: {{ all_must_have_groups_present }}, Optional group present: {{ optional_group_present }}"
    
    - name: Add matching hosts to dynamic group based on conditions
      add_host:
        name: "{{ inventory_hostname }}"
        groups: dynamic_group
      when:
        - all_must_have_groups_present|default(true)
        - optional_group_present|bool

- name: Execute tasks on filtered hosts
  hosts: dynamic_group
  gather_facts: no
  vars_files:
    - creds.yml
  vars:
    ansible_network_os: cisco.ios.ios
    ansible_connection: network_cli
  vars_prompt:
    - name: template_name
      prompt: "Enter the template name"
      private: no
    - name: interface_type
      prompt: "Enter the interface type(s) separated by comma (or 'any' for all types)"
      private: no
    - name: interface_mode
      prompt: "Enter the interface mode(s) separated by comma (or 'any' for all modes)"
      private: no

  tasks:
    - name: Ensure temp directory is absent
      ansible.builtin.file:
        path: "./temp"
        state: absent
      delegate_to: localhost
      run_once: true

    - name: Ensure temp directory exists
      ansible.builtin.file:
        path: "./temp"
        state: directory
      delegate_to: localhost
      run_once: true

    - name: Convert interface_type to list
      set_fact:
        interface_type_list: "{{ interface_type.split(',') }}"
      when: interface_type != 'any'

    - name: Convert interface_mode to list
      set_fact:
        interface_mode_list: "{{ interface_mode.split(',') }}"
      when: interface_mode != 'any'

    - name: Filter interfaces based on type and mode
      set_fact:
        selected_interfaces: "{{ selected_interfaces | default([]) + [item.name] }}"
      loop: "{{ interfaces }}"
      loop_control:
        loop_var: item
      when: >
        (interface_type == 'any' or item.type in interface_type_list) and 
        (interface_mode == 'any' or item.mode in interface_mode_list)

    - name: Debug selected_interfaces variable
      ansible.builtin.debug:
        var: selected_interfaces
    
    - name: Render command from Jinja2 template for selected interfaces
      ansible.builtin.template:
        src: "../templates/shri/{{ template_name }}.j2"
        dest: "./temp/rendered_commands_{{ inventory_hostname }}.txt"
      delegate_to: localhost

    - name: Read the rendered command file
      ansible.builtin.slurp:
        src: "./temp/rendered_commands_{{ inventory_hostname }}.txt"
      register: slurped_commands
      delegate_to: localhost

    - name: Convert slurped content to a variable
      ansible.builtin.set_fact:
        rendered_commands: "{{ (slurped_commands.content | b64decode | trim).split('\n') | reject('match', '^$') | list }}"

    - name: Execute commands on the device
      ansible.netcommon.cli_command:
        command: "{{ item }}"
      loop: "{{ rendered_commands }}"
      when: item | trim != ""
      register: command_output

    - name: Save command output to a file
      ansible.builtin.shell: 
        cmd: "echo '{{ item.stdout_lines | to_nice_json }}' >> ./temp/execution_output.txt"
      loop: "{{ command_output.results }}"
      delegate_to: localhost